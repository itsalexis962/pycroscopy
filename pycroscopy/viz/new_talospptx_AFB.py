"""
talos2pptx.py
(Python 3 script)

AUGUST 2021:
Edits to code done by Alexis Flores-Betancourt
Edits include:

Selecting only HAADF.tif and BF.tif files for STEM 
and being able to run code through all folders/subdirectories
in main folder/directory in one. 

######################################################################
Original author and purpose:

This will allow the user to select a directory containing
Talos data consisting of .TIF files produced by TIA/TUI,
and .BMP files produced by Bruker Esprit/Quantax. The script
will then place them automatically into a PowerPoint .pptx file
with one slide per batch of TIA images, and possibly splitting
the Bruker data across multiple slides if necessary.

Chad Parish
ORNL-MSTD
v0.0 -- 15 May 2018. One subfuction, only reads TIA STEM
v0.0.1 -- 16 May 2018. Add TIA TEM read
v0.0.2 -- 16 May 2018. Add Bruker EDX read
v0.0.3 -- 24 May 2018. Add import of PNGs from MATLAB MVSA codebase
v0.0.3.1 -- 25 May 2018. Fix error in placement of bottom row PNGs
v0.0.3.2 -- 20 July 2018. Fix a Mac compatibility error
v0.0.3.3 -- 4 August 2018. Lint according to PEP8. Refactor
        some code with minimal functionality changes. Major functional
        changes: Bruker or MVSA will split across multiple slides if
        too many images.

To do: add JSON metadata to notes pages for MVSA PNGs

2018
"""


import pptx     # > pip install python-pptx
                #           or
                # > conda install -c conda-forge python-pptx
                # See:
                # http://pbpython.com/creating-powerpoint.html
                # https://python-pptx.readthedocs.io/en/latest/
from pptx import Presentation
from pptx.util import Pt
from PIL import Image
import tkinter
from tkinter import filedialog
import re
import os
import glob
from glob import glob
from datetime import datetime
from pptx.util import Inches
import shutil
import tkfilebrowser

try:
    import hyperspy.api as hs 
    HS = True
except ImportError:
    HS = False
    print('Module hyperspy not found -- cannot embed stage information on slides')



# main()
def main():

    ######remove this manually before deployment
    #path_dir = "C:/work/Python36/temp/1W53"
    #template_file="C:/Users/nmp/Documents/MATLAB/Spectrum_image_analysis/support_scripts/blank_ornl_new.pptx"
    #output_file="C:/work/Python36/temp/1W53/test5.pptx"
    # ############################################################
    #Get the input diretory, the ORNL PowerPoint template, and the
    #name of the output file

    root = tkinter.Tk()


    path_dir = filedialog.askdirectory(
        initialdir="/",
        title="Find Talos data:")
    template_file = filedialog.askopenfilename(
        initialdir="/",
        title="Find Empty PowerPoint file as template",
        filetypes=[("Powerpoint", "*.pptx")])
    print(template_file)
    output_file = filedialog.asksaveasfilename(
        filetypes=[("Powerpoint", "*.pptx")],
        title="Output filename",
        initialdir=path_dir)

    if not output_file.lower().endswith(".pptx"):
    	output_file += ".pptx"
    print(output_file)
    root.destroy()  # remove the GUI panel

    '''
    Grab all files to be placed into PPT:
    The 'files list' will consist of all files in the
    directory and subdirectories to place tif images 
    and elemental mapping bmps into one power point.
    After the code runs through all folders, it will 
    create another list 'pictures' that will consist 
    of only tif files that end with HAADF and BF (this
    is editable and can be modified as needed).
    '''
    files = []
    start_dir = path_dir

    for dir,_,_ in os.walk(start_dir):
    	files.extend(glob(os.path.join(dir,'*.bmp'))) 
    	files.extend(glob(os.path.join(dir,'*.tif')))

 
    pictures = []
    selected = ['HAADF.tif', 'BF.tif']

    for file in files:
        if file.endswith(tuple(selected)):
            pictures.append(file)
  
    files.sort()
    pictures.sort()

    # ############################################################
    prs = Presentation(template_file)
    slide = prs.slides.add_slide(prs.slide_layouts[0])
    try:
        title = slide.shapes.title
        title.text = '{}'.format(path_dir)
    except AttributeError:
        pass

    shape1 = slide.placeholders[1]
    shape1.text = "Autogenerated " + datetime.now().strftime(
            '%Y-%m-%d %H:%M:%S')
    shape1.text_frame

    prs, new_file_list = write_stem_files(pictures, prs, cols=2, rows=1)  # STEM TIFs
    prs = write_tem_files(new_file_list, prs, cols=1, rows=1)  # TEM TIFs

    prs = write_bruker_files(files, prs, cols=4, rows=2)  # BMPs from Bruker

    prs.save(output_file)
    # ############################################################
    return


# ################################################################

def write_stem_files(file_list, prs, cols=2, rows=1):
    """
    write_stem_files takes a presentation prs and a list of filenames
    file_list as inputs, and will add them to slides in prs. This
    will search for the regular experssion xxxx-1-Acquire in the
    filenames, which TIA throws to denote the first outputted of
    the images in a given stack
    """
    file_list = sorted(file_list)

    new_file_list = file_list.copy()

    for i in file_list:
        container = re.search("\d{3,4}-1-[Aa]cquire",i)
        if container == None:
            continue  # back to top of loop
        else:
            # Else means we've found a figure to base a slide around
            inner_list = []
            st = container.start()
            en = container.end()
            file_start = i[0:st+4]

            for j in file_list:
                if file_start in j:  # anyone who matches gets added 
                    inner_list.append(j)         

        # assumes that layout[5] (sixth slide in slide master) is title only!!!
        slide = prs.slides.add_slide(prs.slide_layouts[5])

        slide = add_slide_title(slide, file_start)

        W = prs.slide_width
        H = prs.slide_height

        #W_col = W / cols
        W_col = Inches(6)
        H_row = Pt(60)
 
        try:
            stage_pos = extract_stage(file_start)
            txBox = slide.shapes.add_textbox(
                Pt(20), H, W*0.7, H+Pt(40))
            tf = txBox.text_frame
            p = tf.paragraphs[0]
            p.text = stage_pos
            p.font.size = Pt(16)
            p.font.name = 'Arial'
        except Exception as e:
            stage_pos = e
        
        print(f'{file_start}: {stage_pos}')
            
        for j in range(len(inner_list)):
            left = j * W_col    

            img_path = inner_list[j]
            top = H_row

            # To create space betwwen the pictures, we multiple left some factor greater than 1.
            slide = placePic(slide, img_path, left*1.1, top, W_col)

            new_file_list.remove(inner_list[j])
            txBox = slide.shapes.add_textbox(
                left + Pt(20), top-Pt(20), W_col, 0.1*top)
            tf = txBox.text_frame
            p = tf.paragraphs[0]

            container = re.search(
                "\d{3,4}-\d{1}-[Aa]cquire", inner_list[j])
            name_image = inner_list[j]
            if container == None:
                name_image = "Unparsed"
            else:
                en = container.end()
                name_image = name_image[en:]
            if name_image.endswith(".tif"):
                name_image = name_image[:-4]
            if name_image.endswith(".tiff"):
                name_image = name_image[:-5]
            p.text = name_image
            p.font.size = Pt(16)
            p.font.name = 'Arial'
            

    return prs, new_file_list

# ################################################################

#
# ###############################################################
def write_tem_files(file_list, prs, cols=1, rows=1):
    """
    write_tem_files takes a presentation prs and a list of filenames
    file_list as inputs, and will add them to slides in prs. This
    will search for the regular experssion _xxxx.tif(f) in the
    filenames, which TIA throws to denote the TEM images

    This must run AFTER write_stem_files() because write_stem_files()
    will expunge the STEM-formatted image strings from the list
    """

    file_list = sorted(file_list)

    if rows != 1:
        raise ValueError("rows values other than 1 not yet implemented")


    inner_list = []
    for i in file_list:
        container = re.search("_\d{3,4}.tif", i)
        if container != None:
            inner_list.append( i );

    for j in inner_list:
        file_start, _ = os.path.splitext(j)  # a,_ = is like MATLAB [a,~]=

        slide = prs.slides.add_slide(prs.slide_layouts[5])
        
        slide = add_slide_title(slide, file_start)

        W = prs.slide_width
        H = prs.slide_height

        W_col = W / (cols+1)
        H_row = Pt(60)
        H_size = (H - H_row)

        try:
            stage_pos = extract_stage(file_start)
            txBox = slide.shapes.add_textbox(
                Pt(20), H, W*0.7, H+Pt(40))
            tf = txBox.text_frame
            p = tf.paragraphs[0]
            p.text = stage_pos
            p.font.size = Pt(16)
            p.font.name = 'Arial'
        except Exception as e:
            stage_pos = e

        Wid = min(W_col, H_size)

        left = (W_col) - (Wid / 2)
        img_path = j
        top = H_row

        slide = placePic(slide, img_path, left, top-Pt(20), W_col)
 
    return prs


# ################################################################
def write_bruker_files(file_list, prs, cols=5, rows=2):
    """
    write_bruker_files takes a presentation prs and a list of filenames
    file_list as inputs, and will add them to slides in prs. This
    will search for the regular experssion _HAADF.bmp, _DF4.bmp, etc.,
    in the filenames, which Bruker throws to denote the exported images
    """

    num_slots = cols * rows

    basefilenames = [];

    for i in file_list:
        # Translation: match underscore, then capital letter, then
        # 1-4 capital letters, then zero or one numbers, then .bmp.
        # This will detect, for instance, _HAADF.bmp or _DF2.bmp but
        # not _N.bmp or _Cr.bmp.
        container = re.search("_[A-Z][A-Z]{1,4}[0-9]{,1}.[Bb][Mm][Pp]", i)
        if container:
            header = i[:container.start()]
            if not any(header in base for base in basefilenames):
                basefilenames.append(header)

    # loop over basefilenames gives the list of sets of the images
    for base in basefilenames:
        inner_list = []
        # inner_list will be each group of 
        for j in file_list:
            if base in j:
                inner_list.append(j)

        first_figs=[]  # These go in front of the other figures
        for j in inner_list:
            if ("_HAADF" in j) or \
            ("_BF" in j):
                first_figs.append(inner_list.pop(
                        inner_list.index(j)
                        ))

        inner_list.sort()
        first_figs.sort()

        num_placed = 0  # number of figures placed so far

        # assumes that layout[5] (sixth slide in slide master) is title only!!!
        slide = prs.slides.add_slide(prs.slide_layouts[5])
        
        slide = add_slide_title(slide, base)

        W = prs.slide_width
        H = prs.slide_height

        W_col = W / cols
        H_row1 = Pt(50)#(H / 2) - W_col

        for j in first_figs:
            slide = placePic(slide, j, W_col*(num_placed % cols),
                             H_row1+(num_placed % cols - 1), W_col)
            num_placed += 1
        for count, j in enumerate(inner_list, 1):
            slide = placePic(slide, j, W_col*(num_placed % cols),
                             H_row1+((num_placed // cols) * W_col), W_col)
            num_placed += 1
            if num_placed == num_slots and not count == len(inner_list):
                num_placed = 0
                slide = prs.slides.add_slide(prs.slide_layouts[5])
                slide = add_slide_title(slide, base)

    return prs
# ################################################################


def placePic(slide, img_path, left, top, W_col):
    """
    Will place a picture in the slide at the indicated location
    """
    slide.shapes.add_picture(
                img_path, left, top, width=W_col)

    return slide


def add_slide_title(slide, text_to_add):
    """
    Will add a title to a slide
    """
    title = slide.shapes.title
    texty = title.text_frame
    texty.clear()
    p = texty.paragraphs[0]
    run = p.add_run()
    run.text = text_to_add  # populate the title
    font = run.font
    font.size = Pt(18)
    font.name = 'Arial'

    return slide


def extract_stage(file_start):

    try:
        load_HS = hs.load(file_start+'.emi')
    except Exception as e:
        print(e)

    try:
        # STEM data is a list, not a singleton. Pull the first item:
        loaded = load_HS[0]

    except:
        # TEM data is a singleton
        loaded = load_HS

    alpha = (loaded.original_metadata['ObjectInfo']['ExperimentalDescription']['Stage A_deg'])
    beta = (loaded.original_metadata['ObjectInfo']['ExperimentalDescription']['Stage B_deg'])
    X = (loaded.original_metadata['ObjectInfo']['ExperimentalDescription']['Stage X_um'])
    Y = (loaded.original_metadata['ObjectInfo']['ExperimentalDescription']['Stage Y_um'])
    Z = (loaded.original_metadata['ObjectInfo']['ExperimentalDescription']['Stage Z_um'])
    return f'alpha, beta (degrees)= {alpha}, {beta}, XYZ (microns)= {X}, {Y}, {Z}'










# Fire main() if invoked as a script not an import
if __name__ == "__main__":
    main()




